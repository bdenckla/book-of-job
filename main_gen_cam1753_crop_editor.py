# Initially generated by GitHub Copilot.
"""
Interactive word-crop editor for Cambridge MS Add. 1753 quirkrec images.

Generates an HTML page (.novc/cam1753_crop_editor.html) where each quirkrec
shows its page-crop image with a draggable bounding box initialized from
the Hebrew-metrics word-position estimate.  Adjust boxes with mouse handles
or arrow keys, then Export JSON to clipboard for downstream processing.

Usage:
    .venv\\Scripts\\python.exe main_gen_cam1753_crop_editor.py           # first 6 missing
    .venv\\Scripts\\python.exe main_gen_cam1753_crop_editor.py --batch 10 # next 10 missing
    .venv\\Scripts\\python.exe main_gen_cam1753_crop_editor.py --all      # all missing cam1753 images
    .venv\\Scripts\\python.exe main_gen_cam1753_crop_editor.py 0119 0303  # specific SIDs
"""

import json
import os
import sys
import traceback
import webbrowser
from pathlib import Path

from PIL import Image

ROOT = Path(__file__).resolve().parent
OUT_DIR = ROOT / ".novc"


# Add sibling repo to sys.path so we can import the shared cam1753 package
CAM1753_REPO = ROOT.parent / "codex-index-cam1753"
sys.path.insert(0, str(CAM1753_REPO))

from py_cam1753_word_image.crop import compute_fade_overlay, estimate_word_position
from py_cam1753_word_image.hebrew_metrics import SPACE_WIDTH, join_maqaf
from py_cam1753_word_image.linebreak_search import find_word_in_linebreaks
from py_cam1753_word_image.page import LB_DIR, find_page_for_verse, get_line_bbox, load_page_image

sys.path.insert(0, str(ROOT))
from pyauthor_util.short_id_etc import short_id

with open(ROOT / "out" / "enriched-quirkrecs.json", encoding="utf-8") as _f:
    EQRS = json.load(_f)


# ── Process a single quirkrec ──────────────────────────────────────────


def process_quirkrec(qr):
    """Generate a crop image and return metadata with initial bbox."""
    sid = short_id(qr)
    cv = qr["qr-cv"]
    consensus = qr["qr-consensus"]
    lb_word = qr.get("qr-consensus-ketiv", consensus)
    ch, v = (int(x) for x in cv.split(":"))

    print(f"\n=== {sid} (Job {cv}): {consensus} ===")

    page_id = find_page_for_verse("Job", ch, v)
    if not page_id:
        print(f"  ERROR: Could not find page for Job {cv}")
        return None

    col, line_num, word_idx, line_words = find_word_in_linebreaks(
        LB_DIR, page_id, "Job", ch, v, lb_word
    )
    if col is None:
        print("  ERROR: Could not find word in line-break data")
        return None
    assert line_num is not None and word_idx is not None
    print(f"  Location: page {page_id}, col {col}, line {line_num}, word {word_idx}")

    # Crop coordinates
    crop_left, crop_top, crop_right, crop_bot, target_offset, ls = get_line_bbox(
        page_id, col, line_num
    )

    # Load page image
    img = load_page_image(page_id)

    cl, ct, cr, cb = int(crop_left), int(crop_top), int(crop_right), int(crop_bot)
    tgt_y = target_offset
    tgt_ls = ls

    crop = img.crop((cl, ct, cr, cb)).convert("RGBA")
    crop_w, crop_h = crop.size

    # Target line band
    highlight_top = tgt_y
    highlight_bot = tgt_y + tgt_ls

    # Horizontal word-position estimate
    highlight_left, highlight_right = estimate_word_position(
        line_words, word_idx, crop_w
    )

    # Initial bounding box (red-line region)
    half_ls = tgt_ls // 2
    box_top = max(0, highlight_top - half_ls)
    box_bot = min(crop_h - 1, highlight_bot + half_ls)

    # Fade overlay
    overlay = compute_fade_overlay(
        crop_w, crop_h,
        highlight_left, highlight_right,
        highlight_top, highlight_bot,
    )
    crop = Image.alpha_composite(crop, overlay)

    # Save
    OUT_DIR.mkdir(exist_ok=True)
    out_path = OUT_DIR / f"cam1753_crop_{sid}.png"
    crop.save(out_path)
    print(f"  Saved: {out_path.name} ({crop_w}\u00d7{crop_h})")

    # Context words
    before = line_words[:word_idx]
    matched_word = line_words[word_idx] if word_idx < len(line_words) else consensus
    after = line_words[word_idx + 1:] if word_idx + 1 < len(line_words) else []

    return {
        "sid": sid,
        "cv": cv,
        "consensus": consensus,
        "page": page_id,
        "col": col,
        "line_num": line_num,
        "word_idx": word_idx,
        "before": before,
        "matched_word": matched_word,
        "after": after,
        "img_file": f"cam1753_crop_{sid}.png",
        "crop_w": crop_w,
        "crop_h": crop_h,
        # Initial bounding box in crop-image relative coords (0\u20131)
        "box_left": round(highlight_left / crop_w, 4),
        "box_right": round(highlight_right / crop_w, 4),
        "box_top": round(box_top / crop_h, 4),
        "box_bot": round(box_bot / crop_h, 4),
        # For converting back to page coordinates
        "crop_left_px": cl,
        "crop_top_px": ct,
    }


# ── Generate interactive HTML ──────────────────────────────────────────


def generate_html(results):
    """Build the editor HTML from processed results and open it."""
    # JS-embeddable items data
    items_data = []
    for r in results:
        items_data.append(
            {
                "sid": r["sid"],
                "cv": r["cv"],
                "consensus": r["consensus"],
                "page": r["page"],
                "col": r["col"],
                "lineNum": r["line_num"],
                "wordIdx": r["word_idx"],
                "imgFile": r["img_file"],
                "cropW": r["crop_w"],
                "cropH": r["crop_h"],
                "box": {
                    "left": r["box_left"],
                    "top": r["box_top"],
                    "right": r["box_right"],
                    "bottom": r["box_bot"],
                },
                "cropLeftPx": r["crop_left_px"],
                "cropTopPx": r["crop_top_px"],
            }
        )

    items_json = json.dumps(items_data, ensure_ascii=False)

    # Per-item HTML blocks
    items_html_parts = []
    for i, r in enumerate(results):
        before_joined = join_maqaf(list(r["before"]))
        after_joined = join_maqaf(list(r["after"]))
        target_display = r["matched_word"]
        if before_joined and before_joined[-1].endswith("\u05be"):
            target_display = before_joined.pop() + target_display
        if target_display.endswith("\u05be") and after_joined:
            target_display = target_display + after_joined.pop(0)
        before_html = " ".join(before_joined)
        after_html = " ".join(after_joined)

        items_html_parts.append(
            f'<div class="editor-item" data-idx="{i}">\n'
            f"  <h2>{r['sid']} \u2014 Job {r['cv']} \u2014 {r['consensus']}</h2>\n"
            f"  <p class=\"meta\">Page {r['page']}, col {r['col']}, "
            f"line {r['line_num']}, word {r['word_idx']}</p>\n"
            f'  <div class="crop-box">\n'
            f'    <p class="context">'
            f'<span class="before">{before_html}</span> '
            f'<span class="target">{target_display}</span> '
            f'<span class="after">{after_html}</span></p>\n'
            f'    <div class="img-wrapper" id="wrap-{i}">\n'
            f'      <img id="img-{i}" src="{r["img_file"]}">\n'
            f'      <svg id="svg-{i}" viewBox="0 0 1 1" '
            f'preserveAspectRatio="none"></svg>\n'
            f"    </div>\n"
            f"  </div>\n"
            f"</div>"
        )

    items_html = "\n".join(items_html_parts)

    html = f"""<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>cam1753 Word Crop Editor</title>
<style>
body {{
  background: #222; color: #eee; font-family: sans-serif;
  padding: 10px 20px; margin: 0;
}}

/* ── Toolbar ────────────────────────────────── */
#toolbar {{
  position: sticky; top: 0; z-index: 100;
  background: #333; padding: 8px 12px;
  border-bottom: 1px solid #555;
  display: flex; align-items: center; gap: 12px;
}}
#toolbar button {{
  padding: 6px 14px; cursor: pointer; font-size: 14px;
  border: 1px solid #888; border-radius: 4px;
  background: #444; color: #eee;
}}
#toolbar button.active {{
  background: #668; border-color: #aaf;
}}
#status {{
  font-size: 13px; color: #aaa;
}}

/* ── Items ──────────────────────────────────── */
.editor-item {{
  margin: 20px 0; padding-bottom: 20px;
  border-bottom: 1px solid #444;
}}
.editor-item h2 {{ margin: 5px 0; font-size: 16px; }}
.editor-item.active {{
  border-left: 3px solid #ff4040; padding-left: 10px;
}}
.meta {{
  margin: 2px 0 8px 0; color: #aaa; font-size: 13px;
}}
.crop-box {{ display: inline-block; }}
.context {{
  direction: rtl; unicode-bidi: embed;
  font-size: 20px; margin: 0; padding: 4px 0;
  text-align: center;
  border: 1px solid #555; border-bottom: none;
  background: #2a2a2a;
}}
.context .before, .context .after {{ color: #888; }}
.context .target {{
  color: #fff; background: #553;
  padding: 2px 4px; border-radius: 3px;
}}

/* ── Image + SVG overlay ────────────────────── */
.img-wrapper {{
  position: relative; display: inline-block; line-height: 0;
}}
.img-wrapper img {{
  display: block; border: 1px solid #555;
}}
.img-wrapper svg {{
  position: absolute; top: 0; left: 0;
  width: 100%; height: 100%; pointer-events: none;
}}
.ctrl-point {{
  pointer-events: all !important;
  cursor: grab;
}}
.ctrl-point:hover {{
  fill-opacity: 1;
}}
.ctrl-point.dragging {{
  cursor: grabbing;
}}
</style>
</head>
<body>

<div id="toolbar">
  <button id="fine-btn" class="active" onclick="toggleFine()">Fine</button>
  <button onclick="resetActive()">Reset</button>
  <button onclick="exportJSON()">Export JSON</button>
  <span id="status">Click a handle to begin</span>
</div>

{items_html}

<script>
// ── Data ──────────────────────────────────────
const ITEMS = {items_json};
const N = ITEMS.length;
const FINE_SCALE = 0.2;
let fineMode = true;

// Current box state for each item (0\u20131 relative coords)
const boxes = ITEMS.map(it => ({{
  left:   it.box.left,
  top:    it.box.top,
  right:  it.box.right,
  bottom: it.box.bottom,
}}));
const initBoxes = JSON.parse(JSON.stringify(boxes));

// Active item & side (for keyboard nudge / highlight)
let activeIdx = 0;
let lastSide = 'right';

// Drag state
let dragIdx = -1;
let dragSide = null;
let dragTarget = null;
let dragStartMouse = null;
let dragStartBox = null;

// ── Drawing ───────────────────────────────────

function drawBox(idx) {{
  const svg = document.getElementById('svg-' + idx);
  const b = boxes[idx];
  const bw = b.right - b.left;
  const bh = b.bottom - b.top;
  const isAct = (idx === activeIdx);
  const color = isAct ? '#ff4040' : '#cc3030';
  const hr = isAct ? 0.012 : 0.009;
  const sw = isAct ? 0.005 : 0.003;

  let parts = [];

  // Rectangle
  const dash = fineMode ? '' : ' stroke-dasharray="0.01 0.006"';
  parts.push(
    '<rect x="' + b.left + '" y="' + b.top + '" ' +
    'width="' + bw + '" height="' + bh + '" ' +
    'fill="none" stroke="' + color + '" stroke-width="' + sw + '"' + dash + ' />'
  );

  // Side handles
  const handles = [
    {{ s: 'left',   cx: b.left,               cy: (b.top + b.bottom) / 2 }},
    {{ s: 'right',  cx: b.right,              cy: (b.top + b.bottom) / 2 }},
    {{ s: 'top',    cx: (b.left + b.right) / 2, cy: b.top }},
    {{ s: 'bottom', cx: (b.left + b.right) / 2, cy: b.bottom }},
  ];

  for (const hl of handles) {{
    const cur = (hl.s === 'left' || hl.s === 'right') ? 'ew-resize' : 'ns-resize';
    const fill = (isAct && hl.s === lastSide) ? '#ffff00' : color;
    parts.push(
      '<circle class="ctrl-point" ' +
      'cx="' + hl.cx + '" cy="' + hl.cy + '" r="' + hr + '" ' +
      'fill="' + fill + '" stroke="#fff" stroke-width="0.002" ' +
      'data-idx="' + idx + '" data-side="' + hl.s + '" ' +
      'style="cursor:' + cur + '"/>'
    );
  }}

  svg.innerHTML = parts.join('\\n');
}}

function drawAll() {{
  for (let i = 0; i < N; i++) drawBox(i);
  document.querySelectorAll('.editor-item').forEach((el, i) => {{
    el.classList.toggle('active', i === activeIdx);
  }});
}}

// ── Fine mode ─────────────────────────────────

function toggleFine() {{
  fineMode = !fineMode;
  document.getElementById('fine-btn').classList.toggle('active', fineMode);
  drawAll();
  updateStatus();
}}

// ── Drag handlers ─────────────────────────────

window.addEventListener('mousedown', (e) => {{
  const t = e.target;
  if (!t.classList || !t.classList.contains('ctrl-point')) return;
  dragIdx = parseInt(t.dataset.idx);
  dragSide = t.dataset.side;
  dragTarget = t;
  activeIdx = dragIdx;
  lastSide = dragSide;
  t.classList.add('dragging');

  const svg = document.getElementById('svg-' + dragIdx);
  const sr = svg.getBoundingClientRect();
  dragStartMouse = {{
    x: (e.clientX - sr.left) / sr.width,
    y: (e.clientY - sr.top)  / sr.height,
  }};
  dragStartBox = JSON.parse(JSON.stringify(boxes[dragIdx]));
  e.preventDefault();
}});

window.addEventListener('mousemove', (e) => {{
  if (dragIdx < 0) return;
  const svg = document.getElementById('svg-' + dragIdx);
  const sr = svg.getBoundingClientRect();
  let mx = (e.clientX - sr.left) / sr.width;
  let my = (e.clientY - sr.top)  / sr.height;

  if (fineMode) {{
    mx = dragStartMouse.x + (mx - dragStartMouse.x) * FINE_SCALE;
    my = dragStartMouse.y + (my - dragStartMouse.y) * FINE_SCALE;
  }}
  mx = Math.max(0, Math.min(1, mx));
  my = Math.max(0, Math.min(1, my));

  const b0 = dragStartBox;
  const b  = boxes[dragIdx];
  const MIN = 0.02;

  if (dragSide === 'left') {{
    b.left   = Math.min(b0.right - MIN, mx);
    b.right  = b0.right;
    b.top    = b0.top;
    b.bottom = b0.bottom;
  }} else if (dragSide === 'right') {{
    b.right  = Math.max(b0.left + MIN, mx);
    b.left   = b0.left;
    b.top    = b0.top;
    b.bottom = b0.bottom;
  }} else if (dragSide === 'top') {{
    b.top    = Math.min(b0.bottom - MIN, my);
    b.bottom = b0.bottom;
    b.left   = b0.left;
    b.right  = b0.right;
  }} else if (dragSide === 'bottom') {{
    b.bottom = Math.max(b0.top + MIN, my);
    b.top    = b0.top;
    b.left   = b0.left;
    b.right  = b0.right;
  }}

  drawAll();
  updateStatus();
}});

window.addEventListener('mouseup', () => {{
  if (dragIdx >= 0) {{
    if (dragTarget) dragTarget.classList.remove('dragging');
    dragIdx = -1;
    dragTarget = null;
    drawAll();
  }}
}});

// ── Arrow keys ────────────────────────────────

const ARROW_STEP = 0.002;

window.addEventListener('keydown', (e) => {{
  // F toggles fine mode
  if (e.key === 'f' || e.key === 'F') {{ toggleFine(); return; }}

  // Tab / Shift-Tab cycles active item
  if (e.key === 'Tab') {{
    e.preventDefault();
    activeIdx = (activeIdx + (e.shiftKey ? N - 1 : 1)) % N;
    drawAll();
    updateStatus();
    // Scroll active item into view
    const el = document.querySelector('.editor-item[data-idx="' + activeIdx + '"]');
    if (el) el.scrollIntoView({{ behavior: 'smooth', block: 'center' }});
    return;
  }}

  // 1-4 select side: 1=left, 2=right, 3=top, 4=bottom
  if ('1234'.includes(e.key)) {{
    lastSide = ['left', 'right', 'top', 'bottom'][parseInt(e.key) - 1];
    drawAll();
    updateStatus();
    return;
  }}

  if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) return;
  e.preventDefault();

  const step = fineMode ? ARROW_STEP * FINE_SCALE : ARROW_STEP;
  const b = boxes[activeIdx];

  if (lastSide === 'left') {{
    if (e.key === 'ArrowLeft')  b.left = Math.max(0, b.left - step);
    if (e.key === 'ArrowRight') b.left = Math.min(b.right - 0.02, b.left + step);
  }} else if (lastSide === 'right') {{
    if (e.key === 'ArrowLeft')  b.right = Math.max(b.left + 0.02, b.right - step);
    if (e.key === 'ArrowRight') b.right = Math.min(1, b.right + step);
  }} else if (lastSide === 'top') {{
    if (e.key === 'ArrowUp')   b.top = Math.max(0, b.top - step);
    if (e.key === 'ArrowDown') b.top = Math.min(b.bottom - 0.02, b.top + step);
  }} else if (lastSide === 'bottom') {{
    if (e.key === 'ArrowUp')   b.bottom = Math.max(b.top + 0.02, b.bottom - step);
    if (e.key === 'ArrowDown') b.bottom = Math.min(1, b.bottom + step);
  }}

  drawAll();
  updateStatus();
}});

// ── Status ────────────────────────────────────

function updateStatus() {{
  const b = boxes[activeIdx];
  const it = ITEMS[activeIdx];
  const fl = fineMode ? '  [FINE]' : '';
  document.getElementById('status').textContent =
    it.sid + ' (' + lastSide + '): ' +
    'L=' + b.left.toFixed(3) + ' T=' + b.top.toFixed(3) +
    ' R=' + b.right.toFixed(3) + ' B=' + b.bottom.toFixed(3) + fl;
}}

// ── Reset ─────────────────────────────────────

function resetActive() {{
  boxes[activeIdx] = JSON.parse(JSON.stringify(initBoxes[activeIdx]));
  drawAll();
  updateStatus();
}}

// ── Export ─────────────────────────────────────

function r4(v) {{ return Math.round(v * 10000) / 10000; }}

function exportJSON() {{
  const output = [];
  for (let i = 0; i < N; i++) {{
    const it = ITEMS[i];
    const b  = boxes[i];

    // Convert relative crop coords to page-absolute pixels.
    const absX = Math.round(it.cropLeftPx + b.left * it.cropW);
    const absY = Math.round(it.cropTopPx  + b.top  * it.cropH);
    const absW = Math.round((b.right - b.left) * it.cropW);
    const absH = Math.round((b.bottom - b.top) * it.cropH);

    output.push({{
      sid:      it.sid,
      cv:       it.cv,
      page:     it.page,
      col:      it.col,
      line_num: it.lineNum,
      bbox_abs: {{ x: absX, y: absY, w: absW, h: absH }},
      bbox_rel: {{
        left:   r4(b.left),
        top:    r4(b.top),
        right:  r4(b.right),
        bottom: r4(b.bottom),
      }},
    }});
  }}

  const jsonStr = JSON.stringify(output, null, 2);
  navigator.clipboard.writeText(jsonStr).then(() => {{
    document.getElementById('status').textContent =
      'Exported ' + N + ' items to clipboard!';
    setTimeout(updateStatus, 2000);
  }});
}}

// ── Init ──────────────────────────────────────
drawAll();
updateStatus();
</script>
</body>
</html>
"""

    OUT_DIR.mkdir(exist_ok=True)
    out_path = OUT_DIR / "cam1753_crop_editor.html"
    out_path.write_text(html, encoding="utf-8")
    print(f"\nEditor: {out_path}")
    webbrowser.open(str(out_path))


# ── Main ───────────────────────────────────────────────────────────────


def main():
    use_all = "--all" in sys.argv
    # Parse --batch N
    batch_size = None
    args = sys.argv[1:]
    i = 0
    while i < len(args):
        if args[i] == "--batch":
            batch_size = int(args[i + 1]) if i + 1 < len(args) else 10
            i += 2
        else:
            i += 1
    # Collect any positional args (SIDs) from command line
    cli_sids = {a for a in args if not a.startswith("-") and not a.isdigit()}
    # Remove batch size value from cli_sids if it leaked in
    if batch_size is not None:
        cli_sids.discard(str(batch_size))

    examples = []
    if use_all:
        # Every quirkrec missing a cam1753 image
        for eqr in EQRS:
            sid = short_id(eqr)
            img_path = ROOT / "docs" / "jobn" / "img" / "cam1753" / f"cam1753-{sid}.png"
            if not os.path.exists(img_path):
                examples.append(eqr)
    elif cli_sids:
        # Use SIDs from command line
        for eqr in EQRS:
            sid = short_id(eqr)
            if sid in cli_sids:
                examples.append(eqr)
    else:
        # Default: first N missing quirkrecs
        limit = batch_size if batch_size is not None else 6
        count = 0
        for eqr in EQRS:
            sid = short_id(eqr)
            img_path = ROOT / "docs" / "jobn" / "img" / "cam1753" / f"cam1753-{sid}.png"
            if not os.path.exists(img_path):
                examples.append(eqr)
                count += 1
                if count >= limit:
                    break

    print(f"Processing {len(examples)} quirkrecs...")
    results = []
    for qr in examples:
        try:
            result = process_quirkrec(qr)
            if result:
                results.append(result)
        except Exception as e:
            sid = short_id(qr)
            print(f"  ERROR ({sid}): {e}")
            traceback.print_exc()

    if not results:
        print("No results to display.")
        return

    generate_html(results)


if __name__ == "__main__":
    main()
