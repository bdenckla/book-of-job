# Initially generated by GitHub Copilot.
"""
Check that pyauthor_qr/qr_*.py filenames, RECORD_* variable names,
and hard-coded "qr-word-id" values are mutually consistent.

Checks per file:
  1. Exactly one RECORD_CCVV[_WORDID] dict-literal assignment exists.
  2. The CCVV in the filename matches the CCVV in the RECORD name.
  3. The WORDID suffix (if any) matches between filename and RECORD name.
  4. Multi-record files have "qr-word-id" matching the WORDID suffix.
  5. Single-record files do NOT have "qr-word-id".
  6. If "qr-cv" appears directly in the dict, it matches the CCVV.

Usage:
  python check_qr_consistency.py [path ...]
"""

import ast
import sys
from pathlib import Path


def check_file(filepath: Path) -> list[str]:
    """Check one qr_*.py file.  Returns a list of violation messages."""
    source = filepath.read_text(encoding="utf-8")
    try:
        tree = ast.parse(source, filename=str(filepath))
    except SyntaxError as exc:
        return [f"  SyntaxError: {exc}"]

    stem = filepath.stem  # e.g. "qr_0816_HVA"

    # --- parse filename ---
    try:
        fn_ccvv, fn_wordid = _parse_qr_tag(stem, "qr_")
    except ValueError as exc:
        return [f"  Bad filename: {exc}"]

    # --- find the primary RECORD_* dict assignment ---
    # Imports (ast.ImportFrom) are ignored; only ast.Assign with a Dict
    # value qualifies.
    primary_records: list[tuple[str, ast.Dict]] = []
    for node in ast.iter_child_nodes(tree):
        if not isinstance(node, ast.Assign):
            continue
        if len(node.targets) != 1:
            continue
        tgt = node.targets[0]
        if not isinstance(tgt, ast.Name):
            continue
        if not tgt.id.startswith("RECORD_"):
            continue
        if not isinstance(node.value, ast.Dict):
            continue
        primary_records.append((tgt.id, node.value))

    if not primary_records:
        return ["  No RECORD_* dict-literal assignment found"]
    if len(primary_records) > 1:
        names = [n for n, _ in primary_records]
        return [f"  Multiple RECORD_* dict literals: {names}"]

    rec_name, rec_dict = primary_records[0]

    # --- parse RECORD name ---
    try:
        rec_ccvv, rec_wordid = _parse_qr_tag(rec_name, "RECORD_")
    except ValueError as exc:
        return [f"  Bad RECORD name: {exc}"]

    violations: list[str] = []

    # Check: CCVV match
    if fn_ccvv != rec_ccvv:
        violations.append(
            f"  CCVV mismatch: filename has {fn_ccvv}, RECORD has {rec_ccvv}"
        )

    # Check: WORDID suffix match (filename vs RECORD name)
    if fn_wordid != rec_wordid:
        violations.append(
            f"  WORDID suffix mismatch: filename has {fn_wordid!r}, "
            f"RECORD name has {rec_wordid!r}"
        )

    # Check: qr-word-id key in dict
    dict_wordid = _find_str_value(rec_dict, "qr-word-id")
    if fn_wordid is not None and dict_wordid is None:
        violations.append(
            f"  Filename has WORDID {fn_wordid!r} "
            f"but dict lacks 'qr-word-id'"
        )
    elif fn_wordid is None and dict_wordid is not None:
        violations.append(
            f"  Filename has no WORDID "
            f"but dict has 'qr-word-id': {dict_wordid!r}"
        )
    elif fn_wordid is not None and dict_wordid is not None:
        if fn_wordid != dict_wordid:
            violations.append(
                f"  WORDID value mismatch: filename has {fn_wordid!r}, "
                f"dict 'qr-word-id' has {dict_wordid!r}"
            )

    # Check: qr-cv consistency (only when directly present in the dict,
    # not inherited via **RECORD_CMN spread)
    dict_cv = _find_str_value(rec_dict, "qr-cv")
    if dict_cv is not None:
        expected_cv = _ccvv_to_cv(fn_ccvv)
        if dict_cv != expected_cv:
            violations.append(
                f"  qr-cv mismatch: filename implies {expected_cv!r}, "
                f"dict has {dict_cv!r}"
            )

    return violations


def main():
    if len(sys.argv) > 1:
        paths = [Path(p) for p in sys.argv[1:]]
    else:
        paths = [Path("pyauthor_qr")]

    files_to_check: list[Path] = []
    for path in paths:
        if path.is_file() and path.suffix == ".py" and path.stem.startswith("qr_"):
            files_to_check.append(path)
        elif path.is_dir():
            files_to_check.extend(sorted(path.glob("qr_*.py")))

    total_violations = 0
    for filepath in sorted(files_to_check):
        violations = check_file(filepath)
        if violations:
            print(f"{filepath}:")
            for v in violations:
                print(v)
            total_violations += len(violations)

    if total_violations:
        print(f"\nFound {total_violations} violation(s).")
        return 1
    print(f"No qr consistency violations found ({len(files_to_check)} files checked).")
    return 0


def _ccvv_to_cv(ccvv: str) -> str:
    """Convert CCVV like '0816' to qr-cv format like '8:16'."""
    chapter = int(ccvv[:2])
    verse = int(ccvv[2:])
    return f"{chapter}:{verse}"


def _parse_qr_tag(tag: str, prefix: str) -> tuple[str, str | None]:
    """
    Strip *prefix* (e.g. "qr_" or "RECORD_") and split into
    (ccvv, wordid_or_None).
    """
    rest = tag[len(prefix) :]  # e.g. "0816" or "0816_HVA"
    ccvv = rest[:4]
    if not ccvv.isdigit():
        raise ValueError(f"Expected 4 digits after {prefix!r}, got {ccvv!r}")
    if len(rest) > 4:
        if rest[4] != "_":
            raise ValueError(f"Expected '_' at position 4 in {rest!r}")
        return ccvv, rest[5:]
    return ccvv, None


def _find_str_value(dict_node: ast.Dict, key_name: str) -> str | None:
    """Return the string value for *key_name* if it is a literal key."""
    for k, v in zip(dict_node.keys, dict_node.values):
        if isinstance(k, ast.Constant) and k.value == key_name:
            if isinstance(v, ast.Constant) and isinstance(v.value, str):
                return v.value
    return None


if __name__ == "__main__":
    sys.exit(main())
